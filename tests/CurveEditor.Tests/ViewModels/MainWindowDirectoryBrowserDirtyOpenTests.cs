using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using CurveEditor.Models;
using CurveEditor.Services;
using CurveEditor.ViewModels;
using jordanrobot.MotorDefinitions.Dtos;
using Moq;
using Xunit;

namespace CurveEditor.Tests.ViewModels;

public sealed class MainWindowDirectoryBrowserDirtyOpenTests
{
    private static string TestMotorJson(string motorName)
    {
        var percent = Enumerable.Range(0, 101).ToArray();
        var rpm = percent.Select(p => (double)p).ToArray();

        var dto = new MotorDefinitionFileDto
        {
            SchemaVersion = CurveEditor.Models.MotorDefinition.CurrentSchemaVersion,
            MotorName = motorName,
            Drives =
            [
                new DriveFileDto
                {
                    SeriesName = "Default Drive",
                    Voltages =
                    [
                        new VoltageFileDto
                        {
                            Voltage = 220,
                            Percent = percent,
                            Rpm = rpm,
                            Series = new SortedDictionary<string, SeriesEntryDto>
                            {
                                ["Peak"] = new SeriesEntryDto { Locked = false, Torque = rpm.ToArray() }
                            }
                        }
                    ]
                }
            ]
        };

        return System.Text.Json.JsonSerializer.Serialize(dto);
    }


    private sealed class InMemorySettingsStore : IUserSettingsStore
    {
        private readonly Dictionary<string, string?> _values = new(StringComparer.Ordinal);

        public string? LoadString(string settingsKey) => _values.TryGetValue(settingsKey, out var value) ? value : null;
        public void SaveString(string settingsKey, string? value) => _values[settingsKey] = value;

        public bool LoadBool(string settingsKey, bool defaultValue)
        {
            var value = LoadString(settingsKey);
            return bool.TryParse(value, out var parsed) ? parsed : defaultValue;
        }

        public void SaveBool(string settingsKey, bool value) => SaveString(settingsKey, value.ToString());

        public double LoadDouble(string settingsKey, double defaultValue)
        {
            var value = LoadString(settingsKey);
            return double.TryParse(value, out var parsed) ? parsed : defaultValue;
        }

        public void SaveDouble(string settingsKey, double value)
            => SaveString(settingsKey, value.ToString(System.Globalization.CultureInfo.InvariantCulture));

        public IReadOnlyList<string> LoadStringArrayFromJson(string settingsKey)
        {
            var value = LoadString(settingsKey);
            if (string.IsNullOrWhiteSpace(value))
            {
                return Array.Empty<string>();
            }

            return System.Text.Json.JsonSerializer.Deserialize<string[]>(value) ?? Array.Empty<string>();
        }

        public void SaveStringArrayAsJson(string settingsKey, IReadOnlyList<string> values)
            => SaveString(settingsKey, System.Text.Json.JsonSerializer.Serialize(values));
    }

    private sealed class StubFolderPicker : IFolderPicker
    {
        public Task<string?> PickFolderAsync(CancellationToken cancellationToken) => Task.FromResult<string?>(null);
    }

    private sealed class TestDirectoryBrowserViewModel : DirectoryBrowserViewModel
    {
        public TestDirectoryBrowserViewModel(IDirectoryBrowserService service, IFolderPicker folderPicker, IUserSettingsStore settings)
            : base(service, folderPicker, settings)
        {
        }

        protected override Task InvokeOnUiAsync(Action action)
        {
            action();
            return Task.CompletedTask;
        }
    }

    [Fact]
    public async Task WhenDirtyAndUserCancels_DirectoryBrowserOpenDoesNotLoadFile()
    {
        var fileServiceMock = new Mock<IFileService>(MockBehavior.Strict);
        fileServiceMock.SetupGet(f => f.CurrentFilePath).Returns("c:/tmp/current.json");
        fileServiceMock.SetupGet(f => f.IsDirty).Returns(false);

        var curveGeneratorMock = new Mock<ICurveGeneratorService>(MockBehavior.Loose);
        var validationServiceMock = new Mock<IValidationService>(MockBehavior.Strict);
        validationServiceMock.Setup(v => v.ValidateMotorDefinition(It.IsAny<MotorDefinition>())).Returns(Array.Empty<string>());

        var driveVoltageSeriesServiceMock = new Mock<IDriveVoltageSeriesService>(MockBehavior.Loose);
        var workflowMock = new Mock<IMotorConfigurationWorkflow>(MockBehavior.Loose);

        var settings = new InMemorySettingsStore();

        var promptCalls = 0;
        Func<string, Task<MainWindowViewModel.UnsavedChangesChoice>> prompt = _ =>
        {
            promptCalls++;
            return Task.FromResult(MainWindowViewModel.UnsavedChangesChoice.Cancel);
        };

        var vm = new MainWindowViewModel(
            fileServiceMock.Object,
            curveGeneratorMock.Object,
            validationServiceMock.Object,
            driveVoltageSeriesServiceMock.Object,
            workflowMock.Object,
            new ChartViewModel(),
            new CurveDataTableViewModel(),
            settings,
            prompt);

        var root = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), "curve-test-" + Guid.NewGuid().ToString("N")));
        try
        {
            var filePath = Path.Combine(root.FullName, "a.json");
            await File.WriteAllTextAsync(filePath, TestMotorJson("a"));

            vm.IsDirty = true;

            var browser = new TestDirectoryBrowserViewModel(new DirectoryBrowserService(), new StubFolderPicker(), settings);
            await browser.SetRootDirectoryAsync(root.FullName);
            vm.DirectoryBrowser = browser;

            var rootNode = Assert.Single(browser.RootItems);
            var fileNode = Assert.Single(rootNode.Children, n => !n.IsDirectory && n.DisplayName == "a.json");

            // Trigger open via selection.
            browser.SelectedNode = fileNode;

            await Task.Delay(150);

            Assert.Equal(1, promptCalls);
            fileServiceMock.Verify(f => f.LoadAsync(It.IsAny<string>()), Times.Never);
        }
        finally
        {
            try { root.Delete(recursive: true); } catch { }
        }
    }

    [Fact]
    public async Task WhenDirtyAndUserIgnores_DirectoryBrowserOpenLoadsFile()
    {
        var fileServiceMock = new Mock<IFileService>(MockBehavior.Strict);
        fileServiceMock.SetupGet(f => f.CurrentFilePath).Returns("c:/tmp/current.json");
        fileServiceMock.SetupGet(f => f.IsDirty).Returns(false);

        var curveGeneratorMock = new Mock<ICurveGeneratorService>(MockBehavior.Loose);
        var validationServiceMock = new Mock<IValidationService>(MockBehavior.Strict);
        validationServiceMock.Setup(v => v.ValidateMotorDefinition(It.IsAny<MotorDefinition>())).Returns(Array.Empty<string>());

        var driveVoltageSeriesServiceMock = new Mock<IDriveVoltageSeriesService>(MockBehavior.Loose);
        var workflowMock = new Mock<IMotorConfigurationWorkflow>(MockBehavior.Loose);

        var settings = new InMemorySettingsStore();

        Func<string, Task<MainWindowViewModel.UnsavedChangesChoice>> prompt = _ =>
            Task.FromResult(MainWindowViewModel.UnsavedChangesChoice.Ignore);

        var loadedTcs = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);
        fileServiceMock
            .Setup(f => f.LoadAsync(It.IsAny<string>()))
            .Returns<string>(path =>
            {
                loadedTcs.TrySetResult(path);
                return Task.FromResult(new MotorDefinition { MotorName = "Loaded" });
            });

        var vm = new MainWindowViewModel(
            fileServiceMock.Object,
            curveGeneratorMock.Object,
            validationServiceMock.Object,
            driveVoltageSeriesServiceMock.Object,
            workflowMock.Object,
            new ChartViewModel(),
            new CurveDataTableViewModel(),
            settings,
            prompt);

        var root = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), "curve-test-" + Guid.NewGuid().ToString("N")));
        try
        {
            var filePath = Path.Combine(root.FullName, "a.json");
            await File.WriteAllTextAsync(filePath, TestMotorJson("a"));

            vm.IsDirty = true;

            var browser = new TestDirectoryBrowserViewModel(new DirectoryBrowserService(), new StubFolderPicker(), settings);
            await browser.SetRootDirectoryAsync(root.FullName);
            vm.DirectoryBrowser = browser;

            var rootNode = Assert.Single(browser.RootItems);
            var fileNode = Assert.Single(rootNode.Children, n => !n.IsDirectory && n.DisplayName == "a.json");

            browser.SelectedNode = fileNode;

            var loadedPath = await loadedTcs.Task.WaitAsync(TimeSpan.FromSeconds(2));
            Assert.Equal(filePath, loadedPath);
        }
        finally
        {
            try { root.Delete(recursive: true); } catch { }
        }
    }

    [Fact]
    public async Task WhenDirtyAndUserSaves_DirectoryBrowserOpenSavesThenLoadsFile()
    {
        var fileServiceMock = new Mock<IFileService>(MockBehavior.Strict);
        fileServiceMock.SetupGet(f => f.CurrentFilePath).Returns("c:/tmp/current.json");
        fileServiceMock.SetupGet(f => f.IsDirty).Returns(false);

        var curveGeneratorMock = new Mock<ICurveGeneratorService>(MockBehavior.Loose);
        var validationServiceMock = new Mock<IValidationService>(MockBehavior.Strict);
        validationServiceMock.Setup(v => v.ValidateMotorDefinition(It.IsAny<MotorDefinition>())).Returns(Array.Empty<string>());

        var driveVoltageSeriesServiceMock = new Mock<IDriveVoltageSeriesService>(MockBehavior.Loose);
        var workflowMock = new Mock<IMotorConfigurationWorkflow>(MockBehavior.Loose);

        var settings = new InMemorySettingsStore();

        Func<string, Task<MainWindowViewModel.UnsavedChangesChoice>> prompt = _ =>
            Task.FromResult(MainWindowViewModel.UnsavedChangesChoice.Save);

        var loadedTcs = new TaskCompletionSource<string>(TaskCreationOptions.RunContinuationsAsynchronously);
        fileServiceMock
            .Setup(f => f.LoadAsync(It.IsAny<string>()))
            .Returns<string>(path =>
            {
                loadedTcs.TrySetResult(path);
                return Task.FromResult(new MotorDefinition { MotorName = "Loaded" });
            });

        fileServiceMock
            .Setup(f => f.SaveAsync(It.IsAny<MotorDefinition>()))
            .Returns(Task.CompletedTask);

        var vm = new MainWindowViewModel(
            fileServiceMock.Object,
            curveGeneratorMock.Object,
            validationServiceMock.Object,
            driveVoltageSeriesServiceMock.Object,
            workflowMock.Object,
            new ChartViewModel(),
            new CurveDataTableViewModel(),
            settings,
            prompt);

        vm.CurrentMotor = new MotorDefinition { MotorName = "Current" };
        vm.IsDirty = true;

        var root = Directory.CreateDirectory(Path.Combine(Path.GetTempPath(), "curve-test-" + Guid.NewGuid().ToString("N")));
        try
        {
            var filePath = Path.Combine(root.FullName, "a.json");
            await File.WriteAllTextAsync(filePath, TestMotorJson("a"));

            var browser = new TestDirectoryBrowserViewModel(new DirectoryBrowserService(), new StubFolderPicker(), settings);
            await browser.SetRootDirectoryAsync(root.FullName);
            vm.DirectoryBrowser = browser;

            var rootNode = Assert.Single(browser.RootItems);
            var fileNode = Assert.Single(rootNode.Children, n => !n.IsDirectory && n.DisplayName == "a.json");

            browser.SelectedNode = fileNode;

            var loadedPath = await loadedTcs.Task.WaitAsync(TimeSpan.FromSeconds(2));
            Assert.Equal(filePath, loadedPath);

            fileServiceMock.Verify(f => f.SaveAsync(It.IsAny<MotorDefinition>()), Times.Once);
        }
        finally
        {
            try { root.Delete(recursive: true); } catch { }
        }
    }
}
